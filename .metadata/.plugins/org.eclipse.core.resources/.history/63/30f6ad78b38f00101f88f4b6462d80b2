/**
 * @file    msme_lis3dsh_demo.c
 * @brief   STM32F4-DISCOVERY + LIS3DSH minimal SPI bring-up with MA + 1st-order LPF
 *
 * Pins (F4DISC default):
 *   - SPI1_SCK  = PA5 (AF5)
 *   - SPI1_MISO = PA6 (AF5)
 *   - SPI1_MOSI = PA7 (AF5)
 *   - MEMS_CS   = PE3  (GPIO, manual CS, idle HIGH)
 *
 * SPI:
 *   - Master, 8-bit frames
 *   - Start slow (BR=/256)
 *   - Command: READ = 0x80 | reg, WRITE = reg
 *   - Many boards prefer Mode 3 (CPOL=1, CPHA=1). If reads are 0xFF/0x00, switch to Mode 3.
 */

#include "STM32f407VGT.h"
#include "gpio_driver.h"
#include "spi_driver.h"
#include <stdint.h>
#include <stdio.h>
#include <math.h>

/* ========================================================================== */
/*                              Build-time config                              */
/* ========================================================================== */

/** @brief Output data rate in Hz (must match your LIS3DSH ODR). */
#define APP_FS_HZ              (100.0f)

/** @brief LPF cutoff in Hz. Smaller → smoother, larger → snappier. */
#define APP_FC_HZ              (3.0f)

/** @brief Moving-average window length. */
#define AVG_SAMPLES            (8U)

/** @brief Startup offset-calibration samples (board should be still). */
#define CALIB_SAMPLES          (50U)

/** @brief Status poll tries before timeout (prevents hard-hang). */
#define STATUS_MAX_TRIES       (5000U)

/* ------------ Pin map (STM32F4DISC) ------------ */
#define LED_PORT               GPIOD
#define LED_PIN_GREEN_LX       12U
#define LED_PIN_ORANGE_UPY     13U
#define LED_PIN_RED_RX         14U
#define LED_PIN_BLUE_DOY       15U   /* PD15 is Blue LED on DISC board */

/* ========================================================================== */
/*                           LIS3DSH register map                              */
/* ========================================================================== */

#define LIS_REG_OUT_T          0x0CU
#define LIS_REG_WHO_AM_I       0x0FU
#define LIS_REG_STATUS         0x27U
#define LIS_REG_OUT_X_L        0x28U
#define LIS_REG_OUT_X_H        0x29U
#define LIS_REG_OUT_Y_L        0x2AU
#define LIS_REG_OUT_Y_H        0x2BU
#define LIS_REG_OUT_Z_L        0x2CU
#define LIS_REG_OUT_Z_H        0x2DU
#define LIS_REG_CTRL4          0x20U
#define LIS_REG_CTRL5          0x24U

/* STATUS bits */
#define LIS_STATUS_ZYXDA_Pos   (3U)
#define LIS_STATUS_ZYXDA_Msk   (1U << LIS_STATUS_ZYXDA_Pos)

/* CTRL4 bits (see datasheet)
 * ODR[7:4] = 0b0110 (100 Hz), BDU=1, ZEN,YEN,XEN=1 → 0x6F
 */
#define LIS_CTRL4_100HZ_BDU_XYZ 0x6FU

/* ========================================================================== */
/*                                 SPI wiring                                  */
/* ========================================================================== */

#define SPI1_CS_PORT            GPIOE
#define SPI1_CS_PIN             3U

#define CS_LOW()                GPIO_WritePin(SPI1_CS_PORT, SPI1_CS_PIN, 0)
#define CS_HIGH()               GPIO_WritePin(SPI1_CS_PORT, SPI1_CS_PIN, 1)

/* ========================================================================== */
/*                               Local typedefs                                */
/* ========================================================================== */

/** @brief Single-pole low-pass filter (LPF): y += a * (x - y). */
typedef struct {
	float a; /**< Smoothing factor alpha in [0,1). */
	float y; /**< Filter state (previous output).  */
} LPF1_t;

/* ========================================================================== */
/*                        Static objects / forward decls                       */
/* ========================================================================== */

static SPI_Handle_t hspi1;

/* GPIO/SPI setup */
static void Init_LEDs(void);
static void Init_SPI1_GPIO_CS(void);
static void Config_SPI1_TXRX(void);
static void delay_cycles(volatile uint32_t n);

/* LIS3DSH helpers */
static uint8_t lis_read_u8(uint8_t reg);
static void lis_write_u8(uint8_t reg, uint8_t val);
static void lis_read_multi(uint8_t start_reg, uint8_t *buf, uint8_t len);
static int lis_init(void);
static uint8_t lis_status_data_ready(void);
static int16_t lis_read_axis_16(uint8_t low_addr);

/* Filtering helpers */
static inline float lpf_alpha(float fc_hz, float fs_hz);
static inline void lpf_init(LPF1_t *f, float fc_hz, float fs_hz);
static inline float lpf_update(LPF1_t *f, float x);
static void add_sample(int16_t x, int16_t y, int16_t z, float *x_avg,
		float *y_avg, float *z_avg);

/* ========================================================================== */
/*                                   Main                                      */
/* ========================================================================== */

int main(void) {
	/* State */
	LPF1_t lpf_x, lpf_y, lpf_z;
	float x_off = 0.0f, y_off = 0.0f, z_off = 0.0f;

	/* Bring-up */
	Init_LEDs();
	Init_SPI1_GPIO_CS();
	Config_SPI1_TXRX();
	SPI_PeripheralControl(&hspi1, ENABLE);

	/* Configure LIS3DSH and verify ID */
	if (lis_init() != 0) {
		printf("ERR: LIS3DSH init failed\r\n");
		while (1) {
			delay_cycles(100000);
		}
	}

	/* Initialize LPFs */
	lpf_init(&lpf_x, APP_FC_HZ, APP_FS_HZ);
	lpf_init(&lpf_y, APP_FC_HZ, APP_FS_HZ);
	lpf_init(&lpf_z, APP_FC_HZ, APP_FS_HZ);

	/* Startup offset calibration (board still) */
	for (uint32_t i = 0; i < CALIB_SAMPLES; ++i) {
		x_off += lis_read_axis_16(LIS_REG_OUT_X_L);
		y_off += lis_read_axis_16(LIS_REG_OUT_Y_L);
		z_off += lis_read_axis_16(LIS_REG_OUT_Z_L);
		delay_cycles(50000);
	}
	x_off /= (float) CALIB_SAMPLES;
	y_off /= (float) CALIB_SAMPLES;
	z_off /= (float) CALIB_SAMPLES;

	/* Main loop */
	while (1) {
		/* Wait-for-data with timeout */
		uint32_t tries = 0;
		while (!lis_status_data_ready() && (++tries < STATUS_MAX_TRIES)) { /* spin */
		}
		if (tries >= STATUS_MAX_TRIES) {
			uint8_t who = lis_read_u8(LIS_REG_WHO_AM_I);
			printf("WARN: no data-ready; WHO_AM_I=0x%02X\r\n", (unsigned) who);
			continue;
		}

		/* Read raw axes (16-bit, little-endian) */
		int16_t rx = lis_read_axis_16(LIS_REG_OUT_X_L);
		int16_t ry = lis_read_axis_16(LIS_REG_OUT_Y_L);
		int16_t rz = lis_read_axis_16(LIS_REG_OUT_Z_L);
		/* RAW values */
//		printf("RAW  X:%6d Y:%6d Z:%6d\r\n", (int) rx, (int) ry, (int) rz);
		/* Moving average (integer domain) */
		float x_ma, y_ma, z_ma;
		add_sample(rx, ry, rz, &x_ma, &y_ma, &z_ma);
		/* Moving average values (floats promoted to double) */
//		printf("MA   X:%6.0f Y:%6.0f Z:%6.0f\r\n", (double) x_ma, (double) y_ma,
//				(double) z_ma);

		/* Offset remove (float domain) */
		float x = x_ma - x_off;
		float y = y_ma - y_off;
		float z = z_ma - z_off;
		/* Print offset-removed values */
//		printf("Offset removed: X=%.2f Y=%.2f Z=%.2f\r\n", x, y, z);
		/* LPF (float) */
		float xf = lpf_update(&lpf_x, x);
		float yf = lpf_update(&lpf_y, y);
		float zf = lpf_update(&lpf_z, z);

		/* Print LPF values */
//		printf("LPF filtered : X=%.2f Y=%.2f Z=%.2f\r\n", xf, yf, zf);
		/* RAW values */
		printf("RAW            X:%8d   Y:%8d   Z:%8d\r\n", (int)rx, (int)ry, (int)rz);

		/* Moving average values */
		printf("MA             X:%8.0f   Y:%8.0f   Z:%8.0f\r\n",
		       (double)x_ma, (double)y_ma, (double)z_ma);

		/* Offset-removed values */
//		printf("Offset removed X:%8.2f   Y:%8.2f   Z:%8.2f\r\n",
//		       x, y, z);
//
//		/* LPF values */
//		printf("LPF filtered   X:%8.2f   Y:%8.2f   Z:%8.2f\r\n",
//		       xf, yf, zf);


		const float LSB_TO_G = 0.00006f;  // for ±2g FS
		float ax = xf * LSB_TO_G;
		float ay = yf * LSB_TO_G;
		float az = zf * LSB_TO_G;
		// Roll: rotation around X-axis
		float roll = atan2f(ay, az);

		// Pitch: rotation around Y-axis
		float pitch = atan2f(-ax, sqrtf(ay * ay + az * az));
		float roll_deg = roll * (180.0f / M_PI);
		float pitch_deg = pitch * (180.0f / M_PI);
		int roll_i = (int) (roll_deg);
		int pitch_i = (int) (pitch_deg);

		//printf("Angles: Roll=%d deg, Pitch=%d deg\r\n", roll_i, pitch_i);

	}
}

/* ========================================================================== */
/*                         Function implementations                            */
/* ========================================================================== */

static void add_sample(int16_t x, int16_t y, int16_t z, float *x_avg,
		float *y_avg, float *z_avg) {
	static int16_t buf_x[AVG_SAMPLES], buf_y[AVG_SAMPLES], buf_z[AVG_SAMPLES];
	static uint8_t idx = 0;

	buf_x[idx] = x;
	buf_y[idx] = y;
	buf_z[idx] = z;
	idx = (uint8_t) ((idx + 1U) % AVG_SAMPLES);

	int32_t sx = 0, sy = 0, sz = 0;
	for (uint32_t i = 0; i < AVG_SAMPLES; ++i) {
		sx += buf_x[i];
		sy += buf_y[i];
		sz += buf_z[i];
	}
	*x_avg = (float) (sx / (int32_t) AVG_SAMPLES);
	*y_avg = (float) (sy / (int32_t) AVG_SAMPLES);
	*z_avg = (float) (sz / (int32_t) AVG_SAMPLES);
}

/* ------------------------------- Initlize GPIO -------------------------------- */

static void Init_LEDs(void) {
	GPIO_EnableClock(GPIO_PORT_D, ENABLE);

	GPIO_Config_t led = { 0 };
	led.Mode = GPIO_MODE_OUTPUT;
	led.OutputType = GPIO_OTYPE_PP;
	led.PuPd = GPIO_PULLDOWN;

	GPIO_Init(LED_PORT, LED_PIN_GREEN_LX, &led);
	GPIO_Init(LED_PORT, LED_PIN_RED_RX, &led);
	GPIO_Init(LED_PORT, LED_PIN_ORANGE_UPY, &led);
	GPIO_Init(LED_PORT, LED_PIN_BLUE_DOY, &led);

	GPIO_OSpeed(LED_PORT, LED_PIN_GREEN_LX, GPIO_SPEED_LOW);
	GPIO_OSpeed(LED_PORT, LED_PIN_RED_RX, GPIO_SPEED_LOW);
	GPIO_OSpeed(LED_PORT, LED_PIN_ORANGE_UPY, GPIO_SPEED_LOW);
	GPIO_OSpeed(LED_PORT, LED_PIN_BLUE_DOY, GPIO_SPEED_LOW);

	GPIO_WritePin(GPIOD, LED_PIN_GREEN_LX, HIGH);
	GPIO_WritePin(GPIOD, LED_PIN_RED_RX, LOW);
	GPIO_WritePin(GPIOD, LED_PIN_ORANGE_UPY, LOW);
	GPIO_WritePin(GPIOD, LED_PIN_BLUE_DOY, LOW);
}

/* ------------------------------- LPF (1st) -------------------------------- */

static inline float lpf_alpha(float fc_hz, float fs_hz) {
	const float two_pi_fc = 6.28318530718f * fc_hz;
	return (two_pi_fc) / (two_pi_fc + fs_hz);
}

static inline void lpf_init(LPF1_t *f, float fc_hz, float fs_hz) {
	f->a = lpf_alpha(fc_hz, fs_hz);
	f->y = 0.0f;
}

static inline float lpf_update(LPF1_t *f, float x) {
	f->y += f->a * (x - f->y);
	return f->y;
}

/* ------------------------------ GPIO & SPI -------------------------------- */

static void Init_SPI1_GPIO_CS(void) {
	/* SPI pins */
	GPIO_EnableClock(GPIO_PORT_A, ENABLE);
	GPIO_Config_t af = { 0 };
	af.Mode = GPIO_MODE_ALT;
	af.OutputType = GPIO_OTYPE_PP;
	af.PuPd = GPIO_NOPULL;
	af.AltFunction = 5; /* AF5 = SPI1 */

	GPIO_OSpeed(GPIOA, 5U, GPIO_SPEED_HIGH);
	GPIO_OSpeed(GPIOA, 6U, GPIO_SPEED_HIGH);
	GPIO_OSpeed(GPIOA, 7U, GPIO_SPEED_HIGH);
	GPIO_Init(GPIOA, 7U, &af); /* MOSI */
	GPIO_Init(GPIOA, 6U, &af); /* MISO */
	af.PuPd = GPIO_PULLDOWN; /* define SCK idle on pad if desired */
	GPIO_Init(GPIOA, 5U, &af); /* SCK  */

	/* CS pin */
	GPIO_EnableClock(GPIO_PORT_E, ENABLE);
	GPIO_Config_t cs = { 0 };
	cs.Mode = GPIO_MODE_OUTPUT;
	cs.OutputType = GPIO_OTYPE_PP;
	cs.PuPd = GPIO_PULLUP;
	GPIO_OSpeed(GPIOE, 3U, GPIO_SPEED_HIGH);
	GPIO_Init(GPIOE, SPI1_CS_PIN, &cs);
	CS_HIGH();
}

static void Config_SPI1_TXRX(void) {
	hspi1.SPIx = SPI1;
	hspi1.config.deviceMode = SPI_MODE_MASTER;
	hspi1.config.busConfig = SPI_BUS_FULL_DUPLEX;
	hspi1.config.dff = SPI_DFF_8BITS;

	/* Mode 0 by default; switch to Mode 3 if needed */
	hspi1.config.cpol = SPI_CPOL_LOW;
	hspi1.config.cpha = SPI_CPHA_FIRST;

	hspi1.config.ssm = SPI_SSM_ENABLE; /* software NSS */
	hspi1.config.clkSpeed = 7; /* BR=/256 */

	RCC->APB2ENR |= (1U << 12); /* SPI1 clock */
	SPI_Init(&hspi1);

	/* When SSM=1, set SSI=1 so NSS is seen high internally. */
	hspi1.SPIx->CR1 |= (1U << 8);
}

/* ------------------------------ LIS3DSH SPI ------------------------------- */

static uint8_t lis_read_u8(uint8_t reg) {
	uint8_t tx = (uint8_t) (0x80U | (reg & 0x7FU));
	uint8_t rx = 0, dummy = 0x00;

	CS_LOW();
	(void) SPI_TransmitReceive(&hspi1, &tx, &rx, 1);
	(void) SPI_TransmitReceive(&hspi1, &dummy, &rx, 1);
	CS_HIGH();
	return rx;
}

static void lis_write_u8(uint8_t reg, uint8_t val) {
	uint8_t tx = reg & 0x7FU;
	uint8_t rx = 0;

	CS_LOW();
	(void) SPI_TransmitReceive(&hspi1, &tx, &rx, 1);
	(void) SPI_TransmitReceive(&hspi1, &val, &rx, 1);
	CS_HIGH();
}

static void lis_read_multi(uint8_t start_reg, uint8_t *buf, uint8_t len) {
	uint8_t tx = (uint8_t) (0x80U | (start_reg & 0x7FU));
	uint8_t rx = 0, dummy = 0x00;

	CS_LOW();
	(void) SPI_TransmitReceive(&hspi1, &tx, &rx, 1);
	for (uint8_t i = 0; i < len; ++i) {
		(void) SPI_TransmitReceive(&hspi1, &dummy, &buf[i], 1);
	}
	CS_HIGH();
}

static int lis_init(void) {
	uint8_t who = lis_read_u8(LIS_REG_WHO_AM_I);
	if (who != 0x3FU) {
		printf("ERR: WHO_AM_I=0x%02X (expect 0x3F)\r\n", (unsigned) who);
		return -1;
	}

	/* CTRL4: ODR=100 Hz, BDU=1, XYZ=1 */
	lis_write_u8(LIS_REG_CTRL4, LIS_CTRL4_100HZ_BDU_XYZ);

	/* CTRL5 (24h): BW2:BW1 = 11 -> 50 Hz AA filter, FSCALE = ±2g, 4-wire SPI
	 * Bits: [BW2 BW1 FS2 FS1 FS0 ST2 ST1 SIM] = [1 1 0 0 0 0 0 0] = 0xC0
	 */
	lis_write_u8(LIS_REG_CTRL5, 0xC0); /* AA BW = 50 Hz, FS=±2g */

	delay_cycles(100000);
	return 0;
}

static uint8_t lis_status_data_ready(void) {
	uint8_t s = lis_read_u8(LIS_REG_STATUS);
	return (uint8_t) ((s & LIS_STATUS_ZYXDA_Msk) ? 1U : 0U);
}

static int16_t lis_read_axis_16(uint8_t low_addr) {
	uint8_t buf[2];
	lis_read_multi(low_addr, buf, 2);
	return (int16_t) ((((uint16_t) buf[1]) << 8) | buf[0]);
}

/* ------------------------------- Utilities -------------------------------- */

static void delay_cycles(volatile uint32_t n) {
	while (n--) {
		__asm__("nop");
	}
}
