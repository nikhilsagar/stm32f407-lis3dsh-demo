/**
 * @file    msme_lis3dsh_demo.c
 * @brief   STM32F4-DISCOVERY + LIS3DSH minimal SPI bring-up with LPF (1st-order)
 * @author  You
 *
 * @details
 * Pins (F4DISC default):
 *   - SPI1_SCK  = PA5 (AF5)
 *   - SPI1_MISO = PA6 (AF5)
 *   - SPI1_MOSI = PA7 (AF5)
 *   - MEMS_CS   = PE3  (GPIO, manual CS, idle HIGH)
 *
 * SPI:
 *   - Master, 8-bit frames
 *   - Start slow (BR=/256)
 *   - Command: READ = 0x80 | reg, WRITE = reg
 *   - Many boards prefer Mode 3 (CPOL=1, CPHA=1). If reads are 0xFF/0x00, switch to Mode 3.
 */

#include "STM32f407VGT.h"
#include "gpio_driver.h"
#include "spi_driver.h"
#include <stdint.h>
#include <stdio.h>

/* ========================================================================== */
/*                              Build-time config                              */
/* ========================================================================== */

/** @brief Output data rate in Hz (must match your LIS3DSH ODR). */
#define APP_FS_HZ              (100.0f)

/** @brief LPF cutoff in Hz. Smaller → smoother, larger → snappier. */
#define APP_FC_HZ              (8.0f)

/** @brief Startup offset-calibration samples (board should be still). */
#define CALIB_SAMPLES          (100U)

/** @brief Status poll tries before timeout (prevents hard-hang). */
#define STATUS_MAX_TRIES       (5000U)

/* ------------ Pin map (STM32F4DISC) ------------ */
#define LED_PORT         GPIOD
#define LED_PIN_GREEN_LX    12U
#define LED_PIN_RED_RX      14U
#define LED_PIN_ORANGE_UPY    12U
#define LED_PIN_BLUE_DOY      14U

/* ========================================================================== */
/*                           LIS3DSH register map                              */
/* ========================================================================== */

#define LIS_REG_OUT_T          0x0CU
#define LIS_REG_WHO_AM_I       0x0FU
#define LIS_REG_STATUS         0x27U
#define LIS_REG_OUT_X_L        0x28U
#define LIS_REG_OUT_X_H        0x29U
#define LIS_REG_OUT_Y_L        0x2AU
#define LIS_REG_OUT_Y_H        0x2BU
#define LIS_REG_OUT_Z_L        0x2CU
#define LIS_REG_OUT_Z_H        0x2DU
#define LIS_REG_CTRL4          0x20U
#define LIS_REG_CTRL5          0x24U

/* STATUS bits */
#define LIS_STATUS_ZYXDA_Pos   (3U)
#define LIS_STATUS_ZYXDA_Msk   (1U << LIS_STATUS_ZYXDA_Pos)

/* CTRL4 bits (see datasheet)
 * ODR[7:4] = 0b0110 (100 Hz), BDU=1, ZEN,YEN,XEN=1 → 0x6F
 */
#define LIS_CTRL4_100HZ_BDU_XYZ 0x6FU

/* CTRL5 (full-scale, AA BW). Keep default: ±2g, default BW → 0x00. */
#define LIS_CTRL5_FS2G_DEFAULT  0x00U

/* ========================================================================== */
/*                                 SPI wiring                                  */
/* ========================================================================== */

#define SPI1_CS_PORT            GPIOE
#define SPI1_CS_PIN             3U

#define CS_LOW()                GPIO_WritePin(SPI1_CS_PORT, SPI1_CS_PIN, 0)
#define CS_HIGH()               GPIO_WritePin(SPI1_CS_PORT, SPI1_CS_PIN, 1)

/* ========================================================================== */
/*                               Local typedefs                                */
/* ========================================================================== */

/**
 * @brief Single-pole low-pass filter (LPF): y += a * (x - y).
 */
typedef struct {
	float a; /**< Smoothing factor alpha in [0,1). */
	float y; /**< Filter state (previous output).  */
} LPF1_t;

/* ========================================================================== */
/*                        Static objects / forward decls                       */
/* ========================================================================== */

static SPI_Handle_t hspi1;

/* GPIO/SPI setup */
static void Init_LEDs(void);
static void Init_SPI1_GPIO_CS(void);
static void Config_SPI1_TXRX(void);
static void delay_cycles(volatile uint32_t n);

/* LIS3DSH helpers */
static uint8_t lis_read_u8(uint8_t reg);
static void lis_write_u8(uint8_t reg, uint8_t val);
static void lis_read_multi(uint8_t start_reg, uint8_t *buf, uint8_t len);
static int lis_init(void);
static uint8_t lis_status_data_ready(void);
static int16_t lis_read_axis_16(uint8_t low_addr);

/* LPF helpers */
static inline float lpf_alpha(float fc_hz, float fs_hz);
static inline void lpf_init(LPF1_t *f, float fc_hz, float fs_hz);
static inline float lpf_update(LPF1_t *f, float x);

/* ========================================================================== */
/*                                   Main                                      */
/* ========================================================================== */

/**
 * @brief  Application entry.
 * @return int (never returns)
 */
int main(void) {
	/* State */
	LPF1_t lpf_x, lpf_y, lpf_z;
	float x_off = 0.0f, y_off = 0.0f, z_off = 0.0f;

	/* Bring-up */
	Init_SPI1_GPIO_CS();
	Config_SPI1_TXRX();
	SPI_PeripheralControl(&hspi1, ENABLE);

	/* Configure LIS3DSH and verify ID */
	if (lis_init() != 0) {
		/* Fatal: blink forever or print once */
		printf("ERR: LIS3DSH init failed\r\n");
		while (1) {
			delay_cycles(100000);
		}
	}

	/* Initialize LPFs */
	lpf_init(&lpf_x, APP_FC_HZ, APP_FS_HZ);
	lpf_init(&lpf_y, APP_FC_HZ, APP_FS_HZ);
	lpf_init(&lpf_z, APP_FC_HZ, APP_FS_HZ);

	/* Startup offset calibration (board still) */
	for (uint32_t i = 0; i < CALIB_SAMPLES; ++i) {
		x_off += lis_read_axis_16(LIS_REG_OUT_X_L);
		y_off += lis_read_axis_16(LIS_REG_OUT_Y_L);
		z_off += lis_read_axis_16(LIS_REG_OUT_Z_L);
		delay_cycles(50000);
	}
	x_off /= (float) CALIB_SAMPLES;
	y_off /= (float) CALIB_SAMPLES;
	z_off /= (float) CALIB_SAMPLES;

	/* Main loop */
	while (1) {
		/* Option A: wait-for-data with timeout to avoid hard-hang */
		uint32_t tries = 0;
		while (!lis_status_data_ready() && (++tries < STATUS_MAX_TRIES)) { /* spin */
		}
		if (tries >= STATUS_MAX_TRIES) {
			/* Not fatal—just warn once in a while or re-read WHO_AM_I */
			uint8_t who = lis_read_u8(LIS_REG_WHO_AM_I);
			printf("WARN: no data-ready; WHO_AM_I=0x%02X\r\n", (unsigned) who);
			continue;
		}

		/* Read raw axes */
		int16_t rx = lis_read_axis_16(LIS_REG_OUT_X_L);
		int16_t ry = lis_read_axis_16(LIS_REG_OUT_Y_L);
		int16_t rz = lis_read_axis_16(LIS_REG_OUT_Z_L);

		/* Offset remove (float domain) */
		float x = (float) rx - x_off;
		float y = (float) ry - y_off;
		float z = (float) rz - z_off;

		/* LPF */
		float xf = lpf_update(&lpf_x, x);
		float yf = lpf_update(&lpf_y, y);
		float zf = lpf_update(&lpf_z, z);

		/* Print without float formatting support (scaled ints) */
		int xi = (int) (xf * 10.0f), yi = (int) (yf * 10.0f), zi = (int) (zf
				* 10.0f);
		printf("RAW  X:%6d Y:%6d Z:%6d | LPF X:%d.%01d Y:%d.%01d Z:%d.%01d\r\n",
				rx, ry, rz, xi / 10, xi % 10, yi / 10, yi % 10, zi / 10,
				zi % 10);
	}
}

/* ========================================================================== */
/*                         Function implementations                            */
/* ========================================================================== */

/* ------------------------------- Initlize GPIO -------------------------------- */

/**
 * @brief  Initialize GPIO.
 * @param  None.
 * @return None.
 */
static void Init_LEDs(void) {
	GPIO_EnableClock(GPIO_PORT_D, ENABLE);

	GPIO_Config_t led = { 0 };
	led.Mode = GPIO_MODE_OUTPUT;
	led.OutputType = GPIO_OTYPE_PP;
	led.PuPd = GPIO_PULLDOWN;

	GPIO_Init(LED_PORT, LED_PIN_GREEN_LX, &led);
	GPIO_Init(LED_PORT, LED_PIN_RED_RX, &led);
	GPIO_Init(LED_PORT, LED_PIN_ORANGE_UPY, &led);
	GPIO_Init(LED_PORT, LED_PIN_BLUE_DOY, &led);

	GPIO_OSpeed(LED_PORT, LED_PIN_GREEN_LX, GPIO_SPEED_LOW);
	GPIO_OSpeed(LED_PORT, LED_PIN_RED_RX, GPIO_SPEED_LOW);
	GPIO_OSpeed(LED_PORT, LED_PIN_ORANGE_UPY, GPIO_SPEED_LOW);
	GPIO_OSpeed(LED_PORT, LED_PIN_BLUE_DOY, GPIO_SPEED_LOW);
	GPIO_WritePin(GPIO_PORT_D, LED_PIN_GREEN_LX, LOW);
	GPIO_WritePin(GPIO_PORT_D, LED_PIN_RED_RX, LOW);
	GPIO_WritePin(GPIO_PORT_D, LED_PIN_ORANGE_UPY, LOW);
	GPIO_WritePin(GPIO_PORT_D, LED_PIN_BLUE_DOY, LOW);

}

/* ------------------------------- LPF (1st) -------------------------------- */

/**
 * @brief  Compute alpha for 1st-order LPF using bilinear/RC form.
 * @param  fc_hz  Cutoff frequency (Hz).
 * @param  fs_hz  Sample rate (Hz).
 * @return alpha in [0,1).
 */
static inline float lpf_alpha(float fc_hz, float fs_hz) {
	const float two_pi_fc = 6.28318530718f * fc_hz;
	return (two_pi_fc) / (two_pi_fc + fs_hz);
}

/**
 * @brief  Initialize LPF state.
 */
static inline void lpf_init(LPF1_t *f, float fc_hz, float fs_hz) {
	f->a = lpf_alpha(fc_hz, fs_hz);
	f->y = 0.0f;
}

/**
 * @brief  Process one sample: y += a * (x - y).
 */
static inline float lpf_update(LPF1_t *f, float x) {
	f->y += f->a * (x - f->y);
	return f->y;
}

/* ------------------------------ GPIO & SPI -------------------------------- */

/**
 * @brief  Configure SPI1 pins (PA5/6/7 AF5) and PE3 (CS) as output-high.
 */
static void Init_SPI1_GPIO_CS(void) {
	/* SPI pins */
	GPIO_EnableClock(GPIO_PORT_A, ENABLE);
	GPIO_Config_t af = { 0 };
	af.Mode = GPIO_MODE_ALT;
	af.OutputType = GPIO_OTYPE_PP;
	af.PuPd = GPIO_NOPULL;
	af.AltFunction = 5; /* AF5 = SPI1 */
	GPIO_OSpeed(GPIOA, 5U, GPIO_SPEED_HIGH);
	GPIO_OSpeed(GPIOA, 6U, GPIO_SPEED_HIGH);
	GPIO_OSpeed(GPIOA, 7U, GPIO_SPEED_HIGH);
	GPIO_Init(GPIOA, 7U, &af); /* MOSI */
	GPIO_Init(GPIOA, 6U, &af); /* MISO */
	af.PuPd = GPIO_PULLDOWN; /* define SCK idle on pad if desired */
	GPIO_Init(GPIOA, 5U, &af); /* SCK  */

	/* CS pin */
	GPIO_EnableClock(GPIO_PORT_E, ENABLE);
	GPIO_Config_t cs = { 0 };
	cs.Mode = GPIO_MODE_OUTPUT;
	cs.OutputType = GPIO_OTYPE_PP;
	cs.PuPd = GPIO_PULLUP;
	GPIO_OSpeed(GPIOE, 3U, GPIO_SPEED_HIGH);
	GPIO_Init(GPIOE, SPI1_CS_PIN, &cs);
	CS_HIGH();
}

/**
 * @brief  Configure SPI1: master, 8-bit, full-duplex, slow baud.
 * @note   If reads return 0xFF/0x00, try Mode 3: CPOL=HIGH, CPHA=SECOND.
 */
static void Config_SPI1_TXRX(void) {
	hspi1.SPIx = SPI1;
	hspi1.config.deviceMode = SPI_MODE_MASTER;
	hspi1.config.busConfig = SPI_BUS_FULL_DUPLEX;
	hspi1.config.dff = SPI_DFF_8BITS;

	/* Mode 0 by default; switch to Mode 3 if needed */
	hspi1.config.cpol = SPI_CPOL_LOW;
	hspi1.config.cpha = SPI_CPHA_FIRST;

	hspi1.config.ssm = SPI_SSM_ENABLE; /* software NSS */
	hspi1.config.clkSpeed = 7; /* BR=/256 */

	RCC->APB2ENR |= (1U << 12); /* SPI1 clock */
	SPI_Init(&hspi1);

	/* When SSM=1, set SSI=1 so NSS is seen high internally. */
	hspi1.SPIx->CR1 |= (1U << 8);
}

/* ------------------------------ LIS3DSH SPI ------------------------------- */

/**
 * @brief  Read one register.
 */
static uint8_t lis_read_u8(uint8_t reg) {
	uint8_t tx = (uint8_t) (0x80U | (reg & 0x7FU));
	uint8_t rx = 0, dummy = 0x00;

	CS_LOW();
	(void) SPI_TransmitReceive(&hspi1, &tx, &rx, 1);
	(void) SPI_TransmitReceive(&hspi1, &dummy, &rx, 1);
	CS_HIGH();
	return rx;
}

/**
 * @brief  Write one register.
 */
static void lis_write_u8(uint8_t reg, uint8_t val) {
	uint8_t tx = reg & 0x7FU;
	uint8_t rx = 0;

	CS_LOW();
	(void) SPI_TransmitReceive(&hspi1, &tx, &rx, 1);
	(void) SPI_TransmitReceive(&hspi1, &val, &rx, 1);
	CS_HIGH();
}

/**
 * @brief  Read multiple bytes with auto-increment (set start_reg accordingly).
 */
static void lis_read_multi(uint8_t start_reg, uint8_t *buf, uint8_t len) {
	uint8_t tx = (uint8_t) (0x80U | (start_reg & 0x7FU));
	uint8_t rx = 0, dummy = 0x00;

	CS_LOW();
	(void) SPI_TransmitReceive(&hspi1, &tx, &rx, 1);
	for (uint8_t i = 0; i < len; ++i) {
		(void) SPI_TransmitReceive(&hspi1, &dummy, &buf[i], 1);
	}
	CS_HIGH();
}

/**
 * @brief  Initialize LIS3DSH, verify ID, set ODR=100 Hz, BDU=1, XYZ enable, ±2g.
 * @return 0 on success; non-zero on failure.
 */
static int lis_init(void) {
	/* temperature and WHO_AM_I */
//    (void)lis_read_u8(LIS_REG_OUT_T);
	uint8_t who = lis_read_u8(LIS_REG_WHO_AM_I);
	if (who != 0x3FU) {
		printf("ERR: WHO_AM_I=0x%02X (expect 0x3F)\r\n", (unsigned) who);
		return -1;
	}

	/* CTRL4: ODR=100 Hz, BDU=1, XYZ=1 */
	lis_write_u8(LIS_REG_CTRL4, LIS_CTRL4_100HZ_BDU_XYZ);

	/* CTRL5: FS=±2g default */
	lis_write_u8(LIS_REG_CTRL5, LIS_CTRL5_FS2G_DEFAULT);

	delay_cycles(100000);
	return 0;
}

/**
 * @brief  Check STATUS.ZYXDA (new XYZ data ready).
 * @return 1 if ready; 0 otherwise.
 */
static uint8_t lis_status_data_ready(void) {
	uint8_t s = lis_read_u8(LIS_REG_STATUS);
	return (uint8_t) ((s & LIS_STATUS_ZYXDA_Msk) ? 1U : 0U);
}

/**
 * @brief  Read one 16-bit axis (little-endian) starting at *_L.
 * @param  low_addr  Address of *_L register (e.g., OUT_X_L).
 */
static int16_t lis_read_axis_16(uint8_t low_addr) {
	uint8_t buf[2];
	lis_read_multi(low_addr, buf, 2);
	return (int16_t) ((((uint16_t) buf[1]) << 8) | buf[0]);
}

/* ------------------------------- Utilities -------------------------------- */

static void delay_cycles(volatile uint32_t n) {
	while (n--) {
		__asm__("nop");
	}
}
