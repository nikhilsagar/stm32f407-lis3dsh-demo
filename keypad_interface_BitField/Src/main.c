/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include <stdint.h>
#include <stdio.h>
#include "main.h"

void delay(uint32_t time) {
	for (volatile uint32_t i = 0; i < time; i++);
}

// Register Definitions
#define RCC_AHB1ENR_t    ((volatile RCC_AHB1ENR * const)(0x40023830))
#define GPIOD_MODER_t    ((volatile GPIOx_MODER * const)(0x40020C00))
#define GPIOD_ODR_t      ((volatile GPIOx_ODR   * const)(0x40020C14))
#define GPIOD_IDR_t      ((volatile GPIOx_IDR   * const)(0x40020C10))
#define GPIOD_PUPDR_t    ((volatile GPIOx_PUPDR * const)(0x40020C0C))

char KeyMap[4][4] = {
		{'1', '2', '3', 'A'},
		{'4', '5', '6', 'B'},
		{'7', '8', '9', 'C'},
		{'*', '0', '#', 'D'}
};
int Row[4]={0,1,2,3};
int colm[4]={8,9,10,11};


int main(void)
{
    // Enable GPIOD Clock
    RCC_AHB1ENR_t->GPIODEN = 1;


    // Configure PD0–PD3 as Output (Rows)
    GPIOD_MODER_t->MODER0 = 0x1;
    GPIOD_MODER_t->MODER1 = 0x1;
    GPIOD_MODER_t->MODER2 = 0x1;
    GPIOD_MODER_t->MODER3 = 0x1;
    GPIOD_MODER_t->MODER12 = 0x1;

    // Configure PD8–PD11 as Input (Columns)
    GPIOD_MODER_t->MODER8 = 0x0;
    GPIOD_MODER_t->MODER9 = 0x0;
    GPIOD_MODER_t->MODER10 = 0x0;
    GPIOD_MODER_t->MODER11 = 0x0;

    // Enable Pull-Up Resistors on Columns
    GPIOD_PUPDR_t->PUPDR8  = 0x1;
    GPIOD_PUPDR_t->PUPDR9  = 0x1;
    GPIOD_PUPDR_t->PUPDR10 = 0x1;
    GPIOD_PUPDR_t->PUPDR11 = 0x1;
    while (1){
		for(int r = 0; r<4; r++){
			// Set all rows high initially
			GPIOD_ODR_t->ODR0 = 1;
			GPIOD_ODR_t->ODR1 = 1;
			GPIOD_ODR_t->ODR2 = 1;
			GPIOD_ODR_t->ODR3 = 1;

			switch(Row[r]){
			case 0:  GPIOD_ODR_t->ODR0 = 0; break;
			case 1:  GPIOD_ODR_t->ODR1 = 0; break;
			case 2:  GPIOD_ODR_t->ODR2 = 0; break;
			case 3:  GPIOD_ODR_t->ODR3 = 0; break;
			}

			for(int c=0; c<4; c++){
				char col_val = 1;
				switch(colm[c]){
				case 8:  col_val = GPIOD_IDR_t->IDR8; break;
				case 9:  col_val = GPIOD_IDR_t->IDR9; break;
				case 10:  col_val = GPIOD_IDR_t->IDR10; break;
				case 11:  col_val = GPIOD_IDR_t->IDR11; break;
				}
				if(!(col_val)){
					printf("%c\n",KeyMap[r][c]);
					delay(100000);

				}


				}
			}
    }
}


